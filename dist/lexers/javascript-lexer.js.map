{"version":3,"file":"javascript-lexer.js","names":["BaseLexer","ts","JavascriptLexer","options","callPattern","functionPattern","functions","namespaceFunctions","attr","parseGenerics","typeMap","visitedComments","Set","keys","node","content","forEachLeadingCommentRange","getFullStart","pos","end","kind","commentId","SyntaxKind","MultiLineCommentTrivia","SingleLineCommentTrivia","has","add","text","slice","commentKeys","commentExtractor","call","push","defaultNamespace","map","entry","namespace","keyPrefix","key","filename","parseCommentNode","createCommentNodeParser","parseTree","ArrowFunction","FunctionDeclaration","functionParamExtractor","TaggedTemplateExpression","taggedTemplateExpressionExtractor","CallExpression","expressionExtractor","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","setNamespaces","tFunctionParam","parameters","find","param","name","Identifier","includes","type","typeName","typeArguments","length","LiteralType","literal","tag","template","isTranslationFunction","NoSubstitutionTemplateLiteral","TemplateExpression","emit","expression","escapedText","arguments","elements","optionsArgument","ObjectLiteralExpression","properties","p","keyPrefixValue","initializer","keyArgument","shift","StringLiteral","BinaryExpression","concatenatedString","concatenateString","typeArgument","parseTypeArgument","typeArg","TypeLiteral","members","member","TypeReference","Object","assign","Array","isArray","types","forEach","tp","defaultValue","SpreadAssignment","TrueKeyword","FalseKeyword","ns","commentText","regexp","RegExp","expressions","match","expressionKeys","extract","binaryExpression","string","operatorToken","PlusToken","left","right"],"sources":["../../src/lexers/javascript-lexer.js"],"sourcesContent":["import BaseLexer from './base-lexer.js'\nimport ts from 'typescript'\n\nexport default class JavascriptLexer extends BaseLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.callPattern = '(?<=^|\\\\s|\\\\.)' + this.functionPattern() + '\\\\(.*\\\\)'\n    this.functions = options.functions || ['t']\n    this.namespaceFunctions = options.namespaceFunctions || [\n      'useTranslation',\n      'withTranslation',\n    ]\n    this.attr = options.attr || 'i18nKey'\n    this.parseGenerics = options.parseGenerics || false\n    this.typeMap = options.typeMap || {}\n  }\n\n  createCommentNodeParser() {\n    const visitedComments = new Set()\n\n    return (keys, node, content) => {\n      ts.forEachLeadingCommentRange(\n        content,\n        node.getFullStart(),\n        (pos, end, kind) => {\n          const commentId = `${pos}_${end}`\n          if (\n            (kind === ts.SyntaxKind.MultiLineCommentTrivia ||\n              kind === ts.SyntaxKind.SingleLineCommentTrivia) &&\n            !visitedComments.has(commentId)\n          ) {\n            visitedComments.add(commentId)\n            const text = content.slice(pos, end)\n            const commentKeys = this.commentExtractor.call(this, text)\n            if (commentKeys) {\n              keys.push(...commentKeys)\n            }\n          }\n        }\n      )\n    }\n  }\n\n  setNamespaces(keys) {\n    if (this.defaultNamespace) {\n      return keys.map((entry) => ({\n        ...entry,\n        namespace: entry.namespace || this.defaultNamespace,\n      }))\n    }\n\n    return keys\n  }\n\n  setKeyPrefixes(keys) {\n    if (this.keyPrefix) {\n      return keys.map((key) => ({\n        ...key,\n        keyPrefix: this.keyPrefix,\n      }))\n    }\n\n    return keys\n  }\n\n  extract(content, filename = '__default.js') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      let entry\n\n      parseCommentNode(keys, node, content)\n\n      if (\n        node.kind === ts.SyntaxKind.ArrowFunction ||\n        node.kind === ts.SyntaxKind.FunctionDeclaration\n      ) {\n        this.functionParamExtractor.call(this, node)\n      }\n\n      if (node.kind === ts.SyntaxKind.TaggedTemplateExpression) {\n        entry = this.taggedTemplateExpressionExtractor.call(this, node)\n      }\n\n      if (node.kind === ts.SyntaxKind.CallExpression) {\n        entry = this.expressionExtractor.call(this, node)\n      }\n\n      if (entry) {\n        keys.push(entry)\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    return this.setNamespaces(keys)\n  }\n\n  /** @param {ts.FunctionLikeDeclaration} node */\n  functionParamExtractor(node) {\n    const tFunctionParam =\n      node.parameters &&\n      node.parameters.find(\n        (param) =>\n          param.name &&\n          param.name.kind === ts.SyntaxKind.Identifier &&\n          this.functions.includes(param.name.text)\n      )\n\n    if (\n      tFunctionParam &&\n      tFunctionParam.type &&\n      tFunctionParam.type.typeName &&\n      tFunctionParam.type.typeName.text === 'TFunction'\n    ) {\n      const { typeArguments } = tFunctionParam.type\n      if (\n        typeArguments &&\n        typeArguments.length &&\n        typeArguments[0].kind === ts.SyntaxKind.LiteralType\n      ) {\n        this.defaultNamespace = typeArguments[0].literal.text\n      }\n    }\n  }\n\n  taggedTemplateExpressionExtractor(node) {\n    const entry = {}\n\n    const { tag, template } = node\n\n    const isTranslationFunction =\n      (tag.text && this.functions.includes(tag.text)) ||\n      (tag.name && this.functions.includes(tag.name.text))\n\n    if (!isTranslationFunction) return null\n\n    if (template.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {\n      entry.key = template.text\n    } else if (template.kind === ts.SyntaxKind.TemplateExpression) {\n      this.emit(\n        'warning',\n        'A key that is a template string must not have any interpolations.'\n      )\n      return null\n    }\n\n    return entry\n  }\n\n  expressionExtractor(node) {\n    const entry = {}\n\n    if (\n      this.namespaceFunctions.includes(node.expression.escapedText) &&\n      node.arguments.length\n    ) {\n      const { text, elements } = node.arguments[0]\n\n      // useTranslation\n      if (text) {\n        this.defaultNamespace = text\n        const optionsArgument = node.arguments[1]\n\n        if (\n          optionsArgument &&\n          optionsArgument.kind === ts.SyntaxKind.ObjectLiteralExpression\n        ) {\n          const node = optionsArgument.properties.find(\n            (p) => p.name.escapedText === 'keyPrefix'\n          )\n          if (node != null) {\n            const keyPrefixValue = node.initializer.text\n            this.keyPrefix = keyPrefixValue\n          }\n        }\n        // withTranslation\n      } else if (elements && elements.length) {\n        this.defaultNamespace = elements[0].text\n      }\n    }\n\n    const isTranslationFunction =\n      (node.expression.text && this.functions.includes(node.expression.text)) ||\n      (node.expression.name &&\n        this.functions.includes(node.expression.name.text))\n\n    if (isTranslationFunction) {\n      const keyArgument = node.arguments.shift()\n\n      if (!keyArgument) {\n        return null\n      }\n\n      if (\n        keyArgument.kind === ts.SyntaxKind.StringLiteral ||\n        keyArgument.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n      ) {\n        entry.key = keyArgument.text\n      } else if (keyArgument.kind === ts.SyntaxKind.BinaryExpression) {\n        const concatenatedString = this.concatenateString(keyArgument)\n        if (!concatenatedString) {\n          this.emit(\n            'warning',\n            `Key is not a string literal: ${keyArgument.text}`\n          )\n          return null\n        }\n        entry.key = concatenatedString\n      } else {\n        this.emit(\n          'warning',\n          keyArgument.kind === ts.SyntaxKind.Identifier\n            ? `Key is not a string literal: ${keyArgument.text}`\n            : 'Key is not a string literal'\n        )\n        return null\n      }\n\n      if (this.parseGenerics && node.typeArguments) {\n        let typeArgument = node.typeArguments.shift()\n\n        const parseTypeArgument = (typeArg) => {\n          if (!typeArg) {\n            return\n          }\n          if (typeArg.kind === ts.SyntaxKind.TypeLiteral) {\n            for (const member of typeArg.members) {\n              entry[member.name.text] = ''\n            }\n          } else if (\n            typeArg.kind === ts.SyntaxKind.TypeReference &&\n            typeArg.typeName.kind === ts.SyntaxKind.Identifier\n          ) {\n            const typeName = typeArg.typeName.text\n            if (typeName in this.typeMap) {\n              Object.assign(entry, this.typeMap[typeName])\n            }\n          } else if (Array.isArray(typeArg.types)) {\n            typeArgument.types.forEach((tp) => parseTypeArgument(tp))\n          }\n        }\n\n        parseTypeArgument(typeArgument)\n      }\n\n      let optionsArgument = node.arguments.shift()\n\n      // Second argument could be a string default value\n      if (\n        optionsArgument &&\n        (optionsArgument.kind === ts.SyntaxKind.StringLiteral ||\n          optionsArgument.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral)\n      ) {\n        entry.defaultValue = optionsArgument.text\n        optionsArgument = node.arguments.shift()\n      }\n\n      if (\n        optionsArgument &&\n        optionsArgument.kind === ts.SyntaxKind.ObjectLiteralExpression\n      ) {\n        for (const p of optionsArgument.properties) {\n          if (p.kind === ts.SyntaxKind.SpreadAssignment) {\n            this.emit(\n              'warning',\n              `Options argument is a spread operator : ${p.expression.text}`\n            )\n          } else if (p.initializer) {\n            if (p.initializer.kind === ts.SyntaxKind.TrueKeyword) {\n              entry[p.name.text] = true\n            } else if (p.initializer.kind === ts.SyntaxKind.FalseKeyword) {\n              entry[p.name.text] = false\n            } else {\n              entry[p.name.text] = p.initializer.text || ''\n            }\n          } else {\n            entry[p.name.text] = ''\n          }\n        }\n      }\n\n      if (entry.ns) {\n        if (typeof entry.ns === 'string') {\n          entry.namespace = entry.ns\n        } else if (typeof entry.ns === 'object' && entry.ns.length) {\n          entry.namespace = entry.ns[0]\n        }\n      }\n\n      return entry\n    }\n\n    return null\n  }\n\n  commentExtractor(commentText) {\n    const regexp = new RegExp(this.callPattern, 'g')\n    const expressions = commentText.match(regexp)\n\n    if (!expressions) {\n      return null\n    }\n\n    const keys = []\n    expressions.forEach((expression) => {\n      const expressionKeys = this.extract(expression)\n      if (expressionKeys) {\n        keys.push(...expressionKeys)\n      }\n    })\n    return keys\n  }\n\n  concatenateString(binaryExpression, string = '') {\n    if (binaryExpression.operatorToken.kind !== ts.SyntaxKind.PlusToken) {\n      return\n    }\n\n    if (binaryExpression.left.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.left, string)\n    } else if (binaryExpression.left.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.left.text\n    } else {\n      return\n    }\n\n    if (binaryExpression.right.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.right, string)\n    } else if (binaryExpression.right.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.right.text\n    } else {\n      return\n    }\n\n    return string\n  }\n}\n"],"mappings":"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"}